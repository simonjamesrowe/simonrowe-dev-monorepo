# Implementation Plan: Project Infrastructure

**Branch**: `001-project-infrastructure` | **Date**: 2026-02-22 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-project-infrastructure/spec.md`

## Summary

Set up the foundational monorepo infrastructure for simonrowe.dev: a Gradle Kotlin DSL multi-project build with Spring Boot 3.5.x backend (Java 21, GraalVM native image via `bootBuildImage`), React frontend (Vite), Docker Compose for local/production orchestration, GitHub Actions CI/CD, and full observability (OpenTelemetry Spring Boot Starter, Prometheus via Actuator, structured logging). Quality gates include Checkstyle (Google Java Style), JaCoCo (80% minimum), SonarCloud, and CycloneDX BOM generation.

## Technical Context

**Language/Version**: Java 21 (LTS) for backend, TypeScript/JavaScript (latest stable) for frontend
**Primary Dependencies**: Spring Boot 3.5.x, Spring Data MongoDB, Spring Kafka, Spring Data Elasticsearch, Spring Boot Actuator, OpenTelemetry Spring Boot Starter, React (latest stable), Vite
**Storage**: MongoDB (primary persistence), Elasticsearch (search), Kafka (async messaging)
**Testing**: JUnit 5 + Testcontainers (backend), Vitest (frontend)
**Target Platform**: Docker containers (GraalVM native image for backend, Nginx for frontend)
**Project Type**: Web application (backend + frontend)
**Performance Goals**: Backend native image startup < 1s, CI pipeline < 10 minutes, local bootstrap < 5 minutes
**Constraints**: No Dockerfile for backend (must use bootBuildImage), OTel Java Agent prohibited (native image incompatible)
**Scale/Scope**: Single developer, single deployment target via Docker Compose + Pinggy

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Requirement | Status |
|-----------|------------|--------|
| I. Monorepo with Separate Containers | Backend + frontend in single repo, separate containers. Backend via `bootBuildImage`, frontend via multi-stage Dockerfile. Docker Compose for orchestration. Images to ghcr.io. | PASS |
| II. Modern Java & React Stack | Java 21, Spring Boot 3.5.x, Gradle Kotlin DSL, MongoDB, Kafka, Elasticsearch. GraalVM native image via `org.graalvm.buildtools.native`. Virtual threads enabled. Actuator on separate port. | PASS |
| III. Quality Gates | Checkstyle (Google Java Style), JaCoCo (enforced thresholds), SonarQube on every PR, CycloneDX BOM, Testcontainers for integration tests, frontend tests for critical paths. | PASS |
| IV. Observability & Operability | Prometheus metrics via actuator port, OpenTelemetry via Spring Boot Starter (NOT Java Agent), structured logging. | PASS |
| V. Simplicity & Incremental Delivery | Start with simplest working solution. No premature abstractions. Features as independently testable increments. | PASS |

All gates pass. No violations requiring justification.

## Project Structure

### Documentation (this feature)

```text
specs/001-project-infrastructure/
├── plan.md              # This file
├── research.md          # Technology decisions and rationale
├── data-model.md        # Infrastructure configuration model
├── quickstart.md        # Developer setup guide
├── contracts/
│   └── health-api.yaml  # Management API OpenAPI spec
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── main/
│   │   ├── java/com/simonrowe/backend/
│   │   │   └── BackendApplication.java
│   │   └── resources/
│   │       ├── application.yml
│   │       └── application-dev.yml
│   └── test/
│       └── java/com/simonrowe/backend/
│           └── BackendApplicationTests.java
├── build.gradle.kts
└── (no Dockerfile -- uses bootBuildImage)

frontend/
├── src/
│   ├── App.tsx
│   ├── main.tsx
│   ├── components/
│   ├── pages/
│   └── services/
├── public/
├── index.html
├── package.json
├── vite.config.ts
├── tsconfig.json
└── vitest.config.ts

Dockerfile.frontend              # Multi-stage: Node build + Nginx runtime

gradle/
├── libs.versions.toml           # Version Catalog
└── wrapper/
    ├── gradle-wrapper.jar
    └── gradle-wrapper.properties

build.gradle.kts                 # Root: shared plugin config
settings.gradle.kts              # Multi-project includes
gradlew / gradlew.bat

config/
├── checkstyle/
│   └── google_checks.xml        # Google Java Style rules
└── otel/
    └── otel-collector-config.yaml  # OTel Collector config (prod)

docker-compose.yml               # Local dev: MongoDB, Kafka, Elasticsearch
docker-compose.prod.yml          # Production: all services + Pinggy

.github/workflows/
├── ci.yml                       # PR quality gates
└── publish.yml                  # Main branch image publishing

.gitignore
README.md
```

**Structure Decision**: Web application structure with `backend/` (Gradle subproject, Spring Boot 3.5.x) and `frontend/` (standalone npm/Vite project). Backend container built via `bootBuildImage` (Cloud Native Buildpacks with GraalVM native image). Frontend container built via multi-stage Dockerfile (Node build + Nginx).

## Key Design Decisions

### 1. GraalVM Native Image via bootBuildImage (Constitution I, II)

The backend is compiled to a GraalVM native image using:
- `org.graalvm.buildtools.native` Gradle plugin
- `./gradlew bootBuildImage` produces a minimal OCI container
- No `Dockerfile.backend` -- Paketo Buildpacks handle everything
- Sub-second startup, smaller container, no JVM in runtime

### 2. OpenTelemetry Spring Boot Starter (Constitution IV)

The OpenTelemetry Java Agent is incompatible with GraalVM native images (runtime bytecode instrumentation vs AOT compilation). Instead:
- `io.opentelemetry.instrumentation:opentelemetry-spring-boot-starter`
- Compile-time auto-configuration compatible with Spring AOT
- OTLP export to OTel Collector sidecar in production

### 3. Spring Boot 3.5.x + Java 21 LTS (Constitution II)

- Java 21 is the current LTS with virtual threads, pattern matching, records
- Spring Boot 3.5.x provides mature GraalVM native image support
- Virtual threads enabled via `spring.threads.virtual.enabled=true`

### 4. Dual Docker Compose Configurations (Constitution I)

- `docker-compose.yml`: Infrastructure only (MongoDB, Kafka, Elasticsearch) for local dev with host-based hot-reload
- `docker-compose.prod.yml`: All services containerized including backend (native image), frontend (Nginx), OTel Collector, and Pinggy tunnel

## Complexity Tracking

No violations. All design decisions align with constitution v1.2.0.
